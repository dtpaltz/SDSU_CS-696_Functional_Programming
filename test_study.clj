(= (get {:a 1 :b 2} :b) 2)

(= (get {:a 1 :b 2} :b 10) 2)

(= ({:a 1 :b 2} :b) 2)

(= ({:a 1 :b 2} :b 10) 2)

(= (:b {:a 1 :b 2}) 2)

(= (:b {:a 1 :b 2} 10) 2)

(= (= 2 2.0) false)

(= (== 2 2.0) true)

(= (first '(1 2 3)) 1)

(= (first [1 2 3]) 1)

(= (pop '(1 2 3)) '(2 3))

(= (pop [1 2 3]) [1 2])

(= (cons :a '(1 2 3)) '(:a 1 2 3))

(= (cons :a [1 2 3]) [:a 1 2 3])

(= (conj '(1 2 3) :a) '(:a 1 2 3))

(= (conj [1 2 3] :a) [1 2 3 :a])

(= (number? :a) false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (vector 8 4 2) [8 4 2])

(= (nth [:a :b :c] 2) :c)

(= (first [1 2 3]) 1)

(= (second [1 2 3]) 2)

(= (last [1 2 3]) 3)

(= (rest [1 2 3]) '(2 3))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn sum1
  ([coll]
   (sum1 coll 0))
  ([coll accum]
   (if (empty? coll)
     accum
     (recur (rest coll) (+ accum (first coll))))))




(sum1 [1 2 3 4 5])

(sum1 (range 9900))

(sum1 (range 100000))


(reduce + [1 2 3 4 5])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (vector 8 4 2) [8 4 2])

(= (nth [:a :b :c] 2) :c)

(= (get ["a" "b" "c"] 2) "c")

(= (["a" "b" "c"] 2) "c")

(= (nth [:a :b :c] 2 "rat") :c)

(= (nth [:a :b :c] 4 "rat") "rat")

(= (.indexOf ["a" "b" "c"] "b") 1)

(= (peek ["a" "b" "c"]) "c")

(= (pop ["a" "b" "c"]) ["a" "b"])

(= (conj [1 2 3]  4) [1 2 3 4])

(= (assoc [1 2 3] 0  9) [9 2 3])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (contains? #{1 2} 1) true)

(= (#{2 4} 2) 2)

(= (identity #{2 3 4}) #{2 3 4})

(= (#{2 4} 3) nil)

(= (get #{1 2} 1) 1)

(= (get #{1 2} 3) nil)

(= (get #{1 2} 3 :not-found) :not-found)

(= (conj #{ 1 2 } 3 4 5) #{1 2 3 4 5})

(= (disj #{1 2 3} 2) #{1 3})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (get {:a 1} :a) 1)

(= ({:a 1} :a) 1)

(= (:a {:a 1}) 1)

(= ({2 "b"} 2) "b")

(= (conj {:a 1 :b 2} {:a 3} {:c 4}) {:a 3 :b 2 :c 4})

(= (merge {:a 1 :b 2} {:a 3 :c 4}) {:a 3 :b 2 :c 4})

(= (assoc {:a 1 :b 2} :a 3 :c 4) {:a 3 :b 2 :c 4})

(= (first {:a 1 :b 2 :c 3 :d 4}) [:a 1])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (list 8 4 2) '(8 4 2))

(= (nth '("a" "b" "c") 2) "c")

(= (peek '("a" "b" "c")) "a")

(= (pop '("a" "b" "c")) '("b" "c"))

(= (conj '(1 2 3)  4) '(4 1 2 3))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def add-one (fn [n] (+ 1 n)))


(add-one 5)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (sort < [3 1 2]) '(1 2 3))
(= (sort > [7 2 3 8 4 6 1 5]) [8 7 6 5 4 3 2 1])
(= (sort (fn [a b] (< a b))  [3 1 2]) [1 2 3])
(= (sort #(< %1 %2)  [3 1 2]) [1 2 3])
(sort (fn [a b] (compare (str a) (str b))) [4 3 16])
(sort  #(compare (str %1)  (str %2))  [4 3 16])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn adder
  [n]
  #(+ n %))

(def add-5 (adder 5))

(add-5 10)



(reduce #(if(< %1 %2) %1 %2) [6 9 4 3 7 9 1 2])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (map inc #{1 2 3}) '(2 3 4))

(= (map + [1 2 3] #{4 5 6}) '(5 7 9))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(map-indexed (fn [index item] {:index index :item item}) [1 2 3])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (filter even? [1 2 3 4 5 6 7]) '(2 4 6))

(= (first (filter even? [1 2 3 4 5 6 7])) 2)

(= (filter #{3 5 9 12} [1 2 3 4 5 6 7]) '(3 5))

(= (remove even? [1 2 3 4 5 6 7]) '(1 3 5 7))

(= (keep even? [1 2 3 4 5 6 7]) '(false true false true false true false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (take-while neg? [-2 -1 0 -1 -2 3]) '(-2 -1))

(= (take-while neg? [-2 -1 0 1 2 3]) '(-2 -1))

(= (drop-while neg? [-1 -2 -6 -7 1 2 3 4 -5 -6 0 1]) '(1 2 3 4 -5 -6 0 1))

(= (split-with #(< % 3) [1 2 3 4 5 1]) ['(1 2) '(3 4 5 1)])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (every? even? '(2 4 6)) true)

(= (every? even? '(2 4 7)) false)

(= (every? #{1 2} [1 2 1]) true)

(= (some even? '(2 4 7)) true)

(= (some even? '(1 5 7)) false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(partition 4 (range 8))

(partition 9 (range 20))

(partition 5 3 (range 20))

(partition 9 9 [1 1 1] (range 20))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(for [x [2 3 4]]
  x)

(for [x [2 3 4]
      y [5 9]]
  [x y])

(for [x [2 3 4]
      y [5 9]]
  (* x y))

(for [x [0 1 2 3 4 5 6 7 8]
      :let [y (* x 3)]
      :when (even? y)]
  y)





(for [x [0 1 2]
      y [0 1 2]
      :when (not= x y)]
  [x y])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(iterate inc 2)

(iterate (partial + 2) 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def c 5)


; 2nd element in form
(-> c
    (+ 3)
    (/ 2)
    (- 1))



; last element in form
(->> c
     (+ 3)
     (/ 2)
     (- 1))


(as-> 5 c
      (+ 3 c)
      (/ c 2)
      (- c 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn variable
  [a b & rest]
  (str "a:" a " b:" b " rest:" rest))

(variable 1 2)

(variable 1 2 3)

(variable 1 2 3 4)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (assoc {:a 1 :b 1 :c 1} :a 2 :d 2) {:a 2 :b 1 :c 1 :d 2})

(= (assoc-in [{:a 1} {:a 2}] [0 :a] 5) [{:a  5} {:a 2}])

(= (assoc-in [{:a 1} {:a 2}] [2 :a] 5) [{:a 1} {:a 2} {:a 5}])

(= (assoc-in {:a {:b 1}} [:a :b] 5) {:a {:b 5}})

(= (dissoc {:a 1 :b 2 :c 3} :b) {:a 1 :c 3})

(= (dissoc {:a 1 :b 2 :c 3} :c :b) {:a 1})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (update-in [{:a 1} {:a 2}] [0 :a] inc) [{:a 2} {:a 2}])

(= (update-in [{:a 1} {:a 2}] [0 :a] + 10) [{:a 11} {:a 2}])

(= (update-in {:a {:b 1}} [:a :b] inc) {:a {:b 2}})

;(update {:a 1 :b 1 :c 1} :a inc) ; need to update Clojure to do this

;(update {:a 1 :b 1 :c 1} :a + 10 2) ; need to update Clojure to do this

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (merge [1 2] 2 3 4) [1 2 2 3 4])

(= (merge #{1 2} 2 3 4) #{1 2 3 4})

(= (merge '(1 2) 3 4) '(4 3 1 2))

(= (merge {:a 1} {:b 2}) {:a 1 :b 2})

(= (merge {:a 1} {:b 2 :a 2}) {:a 2 :b 2})

(merge-with inc [1 2 3])

(merge-with concat
            {:even [2 4] :odd [1 3]}
            {:even [4 6 8]})

(merge-with +
            {:a 1  :b 2}
            {:a 9  :b 98 :c 0})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (replace [10 9 8 7 6] [0 2 4]) [10 8 6])

(= (replace {2 :two, 4 :four} [4 2 3 4 5 6 2]) [:four :two 3 :four 5 6 :two])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (compare 1 2) -1)

(= (compare 50 3) 1)

(= (compare 1 1) 0)

(compare [1 2 3] [1 2 3])

(compare [1 2 3] [0 4 5])

(compare [1 2 3] [0 4 5 6])

(compare [1 2 3] nil)

(compare nil [1 2 3])

(compare "abc" "def")

(compare "abc" "abe")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (some even? [1 2 3]) true)

(= (some even? [1 3 5]) nil)

(some #(if (even? %) %) [1 2 3 4])

(some #{2 "two" 3 "three"} [nil 3 2])

(some {2 "two" 3 "three"} [nil 3 2])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(= (empty? nil) true)

(= (empty? []) true)

(= (empty? [1 2 3]) false)

(seq nil)

(seq [])

(seq [1 2 3])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defn sdsu-partial
  [f x]
  #(+ x %))


(def g (sdsu-partial + 5))

(g 3)



;;;;;;;;;;;;;;;;;;


(defn adder
  ([coll]
   (adder 0 coll))
  ([accum coll]
   (if (empty? coll)
     accum
     (recur (+ accum (first coll)) (rest coll)))))




(adder '(1 2 3 4))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defn mymap
  [f coll]
  (map f coll))



(mymap inc [4 5 6])















































